# load custom executable functions
for function in ~/.zsh/functions/*; do
  source $function
done

# extra files in ~/.zsh/configs/pre , ~/.zsh/configs , and ~/.zsh/configs/post
# these are loaded first, second, and third, respectively.
_load_settings() {
  _dir="$1"
  if [ -d "$_dir" ]; then
    if [ -d "$_dir/pre" ]; then
      for config in "$_dir"/pre/**/*(N-.); do
        . $config
      done
    fi

    for config in "$_dir"/**/*(N-.); do
      case "$config" in
        "$_dir"/pre/*)
          :
          ;;
        "$_dir"/post/*)
          :
          ;;
        *)
          if [ -f $config ]; then
            . $config
          fi
          ;;
      esac
    done

    if [ -d "$_dir/post" ]; then
      for config in "$_dir"/post/**/*(N-.); do
        . $config
      done
    fi
  fi
}
_load_settings "$HOME/.zsh/configs"

# aliases
[[ -f ~/.aliases ]] && source ~/.aliases

# don't correct
unsetopt correct_all

# jj to enter vim-mode
bindkey jj vi-cmd-mode

# Case insensitive autocomplete
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# Partial match highlighting
zstyle -e ':completion:*:default' list-colors \
  'reply=("${PREFIX:+=(#bi)($PREFIX:t)()*==34=34}:${(s.:.)LS_COLORS}")'

# Vim like history search
autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey "^[[A" up-line-or-beginning-search # Up
bindkey "^[[B" down-line-or-beginning-search # Down

_git_prompt_info() {
  ref=$(git symbolic-ref HEAD 2> /dev/null)
  if [ -n $ref ]; then
    branch_name="${ref#refs/heads/}"
    branch_name_max_length=$(($COLUMNS/5))
    if [ ${#branch_name} -gt $branch_name_max_length ]; then
      echo "$branch_name[0,$(($branch_name_max_length-3))]..."
    else
      echo $branch_name
    fi
  fi
}

_git_status() {
  git_status=$(cat "/tmp/git-status-$$")
  if [ -n "$(echo $git_status | grep "Changes not staged")" ]; then
    echo "changed"
  elif [ -n "$(echo $git_status | grep "Changes to be committed")" ]; then
    echo "pending"
  elif [ -n "$(echo $git_status | grep "Untracked files")" ]; then
    echo "untracked"
  else
    echo "unchanged"
  fi
}

_git_prompt_color() {
  if [ -n "$1" ]; then
    current_git_status=$(_git_status)
    if [ "changed" = $current_git_status ]; then
      echo "$(_red $1)"
    elif [ "pending" = $current_git_status ]; then
      echo "$(_yellow $1)"
    elif [ "unchanged" = $current_git_status ]; then
      echo "$(_green $1)"
    elif [ "untracked" = $current_git_status ]; then
      echo "$(_cyan $1)"
    fi
  else
    echo "$1"
  fi
}

_color() {
  if [ -n "$1" ]; then
    echo "%B%F{$2}$1%b%f"
  fi
}

_separate()               { if [ -n "$1" ]; then echo " $1"; fi }
_grey()                   { echo "$(_color "$1" grey)" }
_yellow()                 { echo "$(_color "$1" yellow)" }
_green()                  { echo "$(_color "$1" green)" }
_red()                    { echo "$(_color "$1" red)" }
_cyan()                   { echo "$(_color "$1" cyan)" }
_blue()                   { echo "$(_color "$1" blue)" }

_full_path()              { echo "$(_blue "%~")" }
_working_directory()      { echo "$(_blue "%c")" }
_colored_git_branch()     { echo "$(_git_prompt_color "$(_git_prompt_info)")" }

_display_current_vim_mode() {
  if [[ $VIMODE == 'vicmd' ]]; then
    echo "$(_red "✘")"
  else
    echo "$(_green "✔")"
  fi
}

_set_cursor_shape() {
  if [[ $VIMODE == 'vicmd' ]]; then
    echo -e -n "\x1b[\x32 q"
  else
    echo -e -n "\x1b[\x33 q"
  fi
}

function zle-line-init zle-keymap-select {
  VIMODE=$KEYMAP
  zle reset-prompt
}

zle -N zle-line-init
zle -N zle-keymap-select

precmd() { $(git status 2> /dev/null >! "/tmp/git-status-$$") }

# set gitconfig.local keys and define gpair() and gsolo()
gh_name=("${(s/ /)$(echo `git config user.name`)}")
gh_email=("${(s/@/)$(echo `git config user.email`)}")
gh_co_domain=$(echo `git config company.domain`)

gpair() { git commit --amend --no-edit --author "$gh_name & $1 $2 <$gh_name[1]:l+$1:l@$gh_co_domain>" }
gsolo() { git commit --amend --no-edit --author "$gh_name <$gh_email[1]@$gh_email[2]>" }

# function for running sudo with my current environment (ex. esudo passenger start)
esudo() { sudo -E bash -c "$*"; }

# encrypting pdfs with password
if ! command -v pdftk >/dev/null; then
  echo "Please install pdftk"
else
  encryptpdf() {
    if [[ "$1" == "" ]]; then
      echo "Usage: encryptpdf [file_name] [password]"
    else
      if [[ "$2" == "" ]]; then
        echo"\nPlease enter a password: "
        read password_for_pdf
      else
        password_for_pdf="$2"
      fi

      pdf_to_encrypt="$1"
    fi

    pdftk "$pdf_to_encrypt" output "$pdf_to_encrypt.encrypted.pdf" user_pw $password_for_pdf allow printing
  }
fi

export PATH="/usr/local/bin:$PATH"
export PATH="/usr/local/heroku/bin:$PATH"
export PATH="$PATH:/usr/local/lib/node_modules"
export PATH="$HOME/.bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/opt/android-sdk/platform-tools:$PATH"

source "$HOME/.zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
source "$HOME/.zsh/completion/git-remote-branch.plugin.zsh"

source "$CHRUBY_LOCATION/chruby/chruby.sh"
source "$CHRUBY_LOCATION/chruby/auto.sh"

#nvm
source /usr/share/nvm/init-nvm.sh

eval $(dircolors ~/.dircolors)
eval "$(fasd --init auto)"
eval $(keychain --nogui --quiet --agents ssh,gpg -Q --eval id_rsa 2538E93E)

# Base16 Shell
BASE16_SHELL="$HOME/.config/base16-shell/base16-default.dark.sh"
[[ -s $BASE16_SHELL ]] && source $BASE16_SHELL

chruby ruby-2.3.1
PROMPT='$(_working_directory)$(_separate $(_colored_git_branch)) $(_display_current_vim_mode) '
